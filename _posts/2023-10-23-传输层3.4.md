---
layout: post
title: 3.4 可靠数据传输的原理
subtitle: 计网笔记
author: NightSheep
categories: 计网笔记
tags: [笔记,计网]
---
## RDT问题描述
---
- RDT(*Reliable Data Transfer Protocol* 可靠数据传输协议)是为了在不可靠的信道上实现可靠的数据传输
- RDT在应用层、传输层和数据链路层都很重要
- 是网络Top 10问题之一
- 信道的不可靠特点决定了RDT的复杂性
- RDT图片示例：![RDT图片示例](/assets/images/Snipaste_2023-10-23_16-39-39.png)
	- 图片的一个纠正，右下角的rdt_rcv应该是udt_rcv

- **我们将**：
	- 渐增式地开发可靠数据传输协议（ rdt）的发送方和接收方
	- 只考虑单向数据传输
		- 但控制信息是双向流动的
	- 使用有限状态机 (FSM)来描述发送方和接收方
- FSM示例：
![FSM示例](/assets/images/Snipaste_2023-10-23_16-43-24.png)

## RDT1.0:在可靠信道上的可靠数据传输
---
### 概述

- 我们假定下层的信道是完全可靠的：
	- 没有比特出错
	- 没有分组丢失

### FSM描述：

![RDT1.0FSM描述](/assets/images/Snipaste_2023-10-23_16-46-23.png)

## RDT2.0:具有比特差错的信道
---
### 概述

- 下层信道可能会出错：将分组中的比特翻转
	- 用**检验和**来检测比特差错
- 如何从差错中恢复？
	- ACK(*Acknowledgement* 确认应答)：接收方显式地告诉发送方分组已被正确接收
	- NAK(*Negative Acknowledgement* 否定应答)：接收方显式地告诉发送方分组发生了差错
		- 发送方收到NAK后，发送方重传分组
- RDT2.0的新机制：采用差错控制编码进行差错检测
	- 发送方差错控制编码、缓存
	- 接收方使用编码检错
	- 接收方的反馈：控制报文（ACK，NAK）：接收方->发送方
	- 发送方收到反馈相应的动作

### FSM描述

![RDT2.0FSM描述](/assets/images/Snipaste_2023-10-24_14-53-47.png)

## RDT2.1:发送方处理出错的ACK/NAK
---
### RDT2.0存在的问题

- **如果ACK/NAK出错了怎么办？**
	- 发送方不知道接收方发生了什么事情！

- 需要新机制的引入：**序号**

- 处理流程：
	- 发送方在每个分组中加入序号
	- 如果ACK/NAK出错，发送方重传当前分组
	- 接收方丢弃（不发给上层）重复分组

>停等协议：发送方发送一个分组，然后等待接收方的应答

### FSM描述

- **发送方**![RDT2.1FSM描述发送方](/assets/images/Snipaste_2023-10-24_15-05-17.png)
- **接收方**![RDT2.1FSM描述接收方](/assets/images/Snipaste_2023-10-24_15-06-12.png)

### 一些实现的细节

- **发送方**：
	- 分组中需要有序列号
	- 对于停等协议，两个序列号(0,1)就足够了
		- 一次只发送一个未经确认的分组
	- 必须检测ACK/NAK是否出错
	- 状态数变成了两倍
		- 必须记住当前分组的序列号为0还是1
- **接收方**
	- 必须检测接收到的分组是否是重复的
		- 状态会指示希望接收到的分组的序号为0还是1
	- 接收方并不知道发送方是否正确收到了其ACK/NAK
		- 如果接收方之后接收的为老分组，则说明之前的ACK错误
		- 如果接收的是新分组，则说明之前的ACK正确

## RDT2.2:无NAK的协议
---
### 概述

- 功能同rdt2.1，但只使用ACK
	- ACK要编号
- 接收方对最后正确接收的分组发ACK，以替代NAK
	- 接收方的返回报文必须显式地包含被正确接收分组的序号
- 发送方收到重复的ACK（如：再次收到ack0）时，与收到NAK采取相同的动作：重传当前分组
- 为后面一次发送多个数据单位做准备
	- 一次能够发送多个
	- 确认信息减少一半，协议处理简单
	- 使用对前一个数据单位的ACK，代替本数据单位的NAK

### FSM描述

- 大致与RDT2.1相同，红色部分为改进![RDT2.2FSM描述](/assets/images/Snipaste_2023-10-24_15-25-42.png)

## RDT3.0:具有比特差错和分组丢失的信道
---
### 概述

- 下层信道可能会丢失分组（数据或ACK）
	- 会死锁
- 解决方案：发送方等待ACK一段**合理的时间**
	- 发送端超时重传：如果到时没有收到ACK则重传(timeout)
		- 链路层的timeout时间是确定的
		- 传输层timeout时间是适应式的

- 如果分组（或ACK）只是被延迟了
	- 重传将会导致数据重复，但是这并不是问题。
		- 利用序列号已经可以处理这个问题
		- 接收方必须指明被正确接收的序列号

- 需要一个倒计数定时器

### FSM描述

- 发送方![RDT3.0FSM描述](/assets/images/Snipaste_2023-10-24_15-39-45.png)
- 接收方与RDT2.2无差别

### RDT3.0的性能

- RDT3.0在链路容量较大时性能很差![性能分析](/assets/images/Snipaste_2023-10-24_15-47-30.png)

- 改进：**流水线协议**

## 流水线协议
---
### 概述

- **流水线**：允许发送方在未得到对方确认的情况下一次发送多个分组
	- 必须增加序号的范围:用多个bit表示分组的序号
	- 在发送方/接收方要有缓冲区
		- 发送方缓冲：未得到确认，可能需要重传
		- 接收方缓存：上层用户取用数据的速率≠接收到的数据速率；接收到的数据可能乱序，排序交付（保证可靠性）
	- 两种通用的流水线协议：GBN(*GO-BACK-N* 回退N步)和SR(*Selective Repeat* 选择重传)

### 滑动窗口协议

- 发送缓冲区
	- 形式：内存中的一个区域，落入缓冲区的分组可以发送
	- 功能：用于存放已发送，但是没有得到确认的分组
	- 必要性：需要重发时可用
- 发送缓存区的大小：
	- 一次最多可以发送多少个未经确认的分组
	- 停止等待协议=1
	- 流水线协议>1，合理的值，不能很大，链路利用率不能够超100%
- 发送缓冲区中的分组
	- 未发送的：落入发送缓冲区的分组，可以连续发送出去
	- 已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除
- 发送窗口：发送缓冲区内容的一个范围
	- 那些已发送但是未经确认分组的序号构成的空间
	- 发送窗口的最大值<=发送缓冲区的大小
- 发送窗口的移动：前沿移动
	- 一开始：没有发送任何一个分组
		- 后沿=前沿
		- 之间为发送窗口的尺寸=0
	- 每发送一个分组，前沿前移一个单位
	- 发送窗口前沿移动的极限：不能够超过发送缓冲区
- 发送窗口的移动：后沿移动
	- 条件：收到老分组的确认
	- 结果：发送缓冲区罩住新的分组，来了分组可以发送
	- 移动的极限：不能够超过前沿

- 接收窗口
	- 接收窗口=接收缓冲区
	- 接收窗口用于控制哪些分组可以接收
		- 只有收到的分组序号落入接收窗口内才允许接收
		- 若序号在接收窗口之外，则丢弃
	- 接收窗口尺寸Wr=1，则只能顺序接收
	- 接收窗口尺寸Wr>1，则可以乱序接收
		- 但提交给上层的分组，要按序
	- 接收窗口的滑动和发送确认
		- 滑动：
			- 低序号的分组到来，接收窗口移动
			- 高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动
		- 发送确认：
			- 接收窗口尺寸=1； 发送连续收到的最大的分组确认（累计确认）
			- 接收窗口尺寸>1； 收到分组，发送那个分组的确认（非累计确认）

### GBN协议

- 发送窗口>1
- 接收窗口=1
- 发送端最多在流水线中有N个未确认的分组
- 接收端只是发送累计型确认
	-  发送连续收到的最大的分组确认
	- 接收端如果发现gap，不确认新到来的分组
- 发送端拥有对最老的确认分组的定时器
	- 只需设置**一个定时器**
	- 当定时器超时时，重传所有未确认分组
- 发送方FSM![GBN发送方FSM](/assets/images/Snipaste_2023-10-24_16-19-42.png)
- 接收方FSM![GBN接收方FSM](/assets/images/Snipaste_2023-10-24_16-20-49.png)
### SR协议

- 发送窗口>1
- 接收窗口>1
- 发送端最多在流水线中有N个未确认的分组
- 接收方对每个到来的分组单独确认
- 发送方为每个未确认的分组保持一个定时器
	- 当定时器超时时，只是重发超时的未确认分组

### GBN协议和SR协议的异同

- 相同之处：
	- 发送窗口>1
	- 一次能够可发送多个未经确认的分组
- 不同之处：
	- GBN :接收窗口尺寸=1
		- 接收端：只能顺序接收
		- 发送端：从表现来看，一旦一个分组没有发成功，如：0,1,2,3,4;假如1未成功，234都发送出去了，要返回1再发送；GB1
	- SR:接收窗口尺寸>1
		- 接收端：可以乱序接收
		- 发送端：发送0,1,2,3,4，一旦1未成功，2,3,4,已发送，无需重发，选择性发送1
![对比](/assets/images/Snipaste_2023-10-24_16-25-23.png)