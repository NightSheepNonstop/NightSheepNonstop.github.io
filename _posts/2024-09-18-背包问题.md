---
layout: post
title: 背包问题
subtitle: 动态规划
author: NightSheep
categories: 算法笔记
tags: [笔记,动态规划,c++]
---

## DP思路

---

- 状态表示
  - 该状态表示的是哪个集合？
  - 该状态的值代表的是集合的什么属性？
- 状态计算
  - 即集合划分
    - 要求不重不漏

## 01背包

---

- 每种物品**只有一个**
- 状态 $f[i][j]$:前i个物品，背包容量j下的最大价值
- 二维：$f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])$
- 一维优化：$f[j] = max(f[j], f[j - v[i]] + w[i])$
  - 循环需**逆序**进行，防止用更新过的状态继续更新

## 完全背包

---

- 每种物品有**无数个**
- 状态 $f[i][j]$:前i种物品，背包容量j下的最大价值
- 朴素的DP：$f[i] [j] = max( f[i-1][j] , f[i - 1][j - v[i]]+w[i] , f[i - 1][j - 2 * v[i]] + 2 * w[i] , f[i - 1][j - k * v[i]] + k * w[i],\dots)$ 
- 优化：
  - 注意到：$f[i][j - v[i]] = max( f[i-1][j - v[i]] , f[i-1][j - 2 * v[i]] + w[i] , f[i-1][j - 3 * v[i]] + 2 * w[i],\dots) $
  - 所以有：$f[i][j] = max(f[i][j-v[i]] + w[i], f[i-1][j])$
- 一维优化：$ f[j] = max(f[j],f[j-v[i]]+w[i]);$
  - 循环**正序**进行

## 多重背包

---

- 每种物品有$S_i$个
- 状态 $f[i][j]$:前i种物品，背包容量j下的最大价值
- 朴素的DP：$f[i] [j] = max( f[i-1][j] , f[i - 1][j - v[i]]+w[i] , f[i - 1][j - 2 * v[i]] + 2 * w[i] , f[i - 1][j - k * v[i]] + k * w[i],\dots)$ 
  - 与完全背包类似，但由于项数不同，无法采用相同的优化方式
- 二进制优化

## 分组背包

---

- 有$N$组物品，**每组只能取一个**
- 状态 $f[i][j]$:前i组物品，背包容量j下的最大价值
- 与01背包问题类似，但是需要多一重循环枚举组内最大值
-  一维优化：$f[j] = max(f[j], f[j - v[i][k]] + w[i][k])$